<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="out/css/style.css">
    <title>Ali Abu Ras JS Study</title>
</head>

<body>
    <div id="AliStudyContainer">

        <div class="sectionButton" id="sectioin1" data-section="section1"> Data Types</div>
        <section class="sectionContent sectionContentHide" id="section1">
            <div class="content">
                There's 7 types of Data Types on Javascript
                <ol>
                    <li>
                        <span class="type">Numbers: </span>
                        <span class="discription"> an integer or a floating-point number </span>
                        <span class="example"> 3, 3.234, 3e-2 etc. </span>
                    </li>

                    <li>
                        <span class="type">String: </span>
                        <span class="discription"> represents textual data </span>
                        <span class="example"> "hello world!" 'hello' </span>
                    </li>


                    <li>
                        <span class="type">Boolean: </span>
                        <span class="discription"> Any of two values: true or false </span>
                        <span class="example"> true and false </span>
                    </li>


                    <li>
                        <span class="type">undefined: </span>
                        <span class="discription"> a data type whose variable is not initialized </span>
                        <span class="example"> let a; </span>
                    </li>


                    <li>
                        <span class="type">null: </span>
                        <span class="discription"> denotes a null value </span>
                        <span class="example"> let a = null; </span>
                    </li>


                    <li>
                        <span class="type">Symbol: </span>
                        <span class="discription"> data type whose instances are unique and immutable </span>
                        <span class="example"> let value = Symbol('hello'); </span>
                    </li>


                    <li>
                        <span class="type">BigInt: </span>
                        <span class="discription"> an integer with arbitrary precision </span>
                        <span class="example"> 900719925124740999n , 1n etc </span>
                    </li>
                </ol>



                <div class="discription">JavaScript is a dynamically typed (loosely typed) language. JavaScript
                    automatically determines the variables' data type for you.

                    It also means that a variable can be of one data type and later it can be changed to another
                    data type.

                    <code>
                        // data is of undefined type
                        let data;
                        // data is of integer type
                        data = 5;
                        // data is of string type
                        data = "JavaScript Programming";
                    </code>
                </div>

                <div class="important"> the VALUE has the type not the variable</div>

                <div class="discription">
                    How to check value type
                    <code>
                        let value = 1; 
                        <span class="keyword">typeof</span> value // number
                    </code>
                </div>
            </div>
        </section>


        <div class="sectionButton" id="sectioin2" data-section="section2"> let, const and var</div>
        <section class="sectionContent sectionContentHide" id="section2">
            <div class="content">
                <div class="discription">
                    A <span class="keyword">var</span> variable can be redeclared and updated.
                    <code>
                        <span class="keyword">var</span> points = 50; 
                        <span class="keyword">var</span> points = 60;
                     </code>
                </div>


                <div class="discription">
                    A <span class="keyword">let</span> variable be be updated but not redeclared.
                    <PRE>
<code>
<span class="keyword">let</span> points = 50;
points = 60;
</code>
but this will create an error
<error>
let points = 50;
let points = 60;
// In the console I get an error:
    Uncaught SyntaxError: Identifier 'points' has already been declared
</error>
</PRE>
                </div>
                <div class="discription">
                    A <span class="keyword">const</span> variables cannot be updated. <span class="keyword">let</span>
                    variables are made to be updated.
                    <PRE>
<code>
    // If I define the const variable:
    <span class="keyword">const</span> key = 'xyz123';
    // Then try to redeclare it:
</code>
<error>
    key = 'xyz1234'
    // I get the following error:
    Uncaught TypeError: Assignment to constant variable.
</error>
</PRE>

                </div>
            </div>
        </section>



        <div class="sectionButton" id="sectioin3" data-section="section3"> Strings and Template Literals</div>
        <section class="sectionContent sectionContentHide" id="section3">
            <div class="content">

                <div class="discription">
                    The String object is used to represent and manipulate a sequence of characters.
                    Strings are useful for holding data that can be represented
                    in text form. Some of the most-used operations on strings are to
                    check their length, to build and concatenate them using the + and += string operators,
                    checking for the existence or location of substrings with the <code class="inline">indexOf()</code>
                    method,
                    or extracting substrings with the <code class="inline">substring()</code> method.
                    <code>
<PRE>
const string1 = "A string primitive";
const string2 = 'Also a string primitive';
const string3 = `Yet another string primitive`;
const string4 = new String("A String object");
</PRE>
                     </code>

                </div>

                <div class="discription">
                    Template literals are string literals allowing embedded expressions. You can use multi-line strings
                    and string interpolation features with them.
                    They were called "template strings" in prior editions of the ES2015 specification.
                    <code>
<PRE>
`string text`
`string text line 1
    string text line 2`
`string text ${expression} string text`
tag`string text ${expression} string text`
</PRE>
                    </code>

                    <code>
                        let a = 5;
                        let b = 10;
                        console.log(`Fifteen is ${a + b} and
                        not ${2 * a + b}.`);
                        // "Fifteen is 15 and
                        // not 20."
                    </code>

                    <code>
                        const classes = `header ${ isLargeScreen() ? '' :
                                        `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;
                    </code>
                </div>

            </div>
        </section>


        <div class="sectionButton" id="sectioin4" data-section="section4"> IF/ELSE</div>
        <section class="sectionContent sectionContentHide" id="section4">
            <div class="content">

                <div class="discription">
                    The <span class="keyword">if</span> statement executes a statement <span class="keyword">if</span> a
                    specified condition is truthy. If the condition is falsy, another statement can be executed.
                    method,
                    <code>
                        <PRE>

function testNum(a) {
    let result;
    if (a > 0) {
        result = 'positive';
    } else {
        result = 'NOT positive';
    }
    return result;
    }
    
    console.log(testNum(-5));
    // expected output: "NOT positive"
                        </PRE>
                     </code>

                </div>

                <div class="discription">
                    Multiple <span class="keyword">if...else </span>statements can be nested to create an<span
                        class="keyword"> else if </span>clause. Note that there is no <span class="keyword"> elseif
                    </span> (in one word) keyword in JavaScript.
                    <code>
                        <PRE>
if (condition1)
    statement1
else if (condition2)
    statement2
else if (condition3)
    statement3
    ...
else
    statementN
                          </PRE>
                     </code>
                    <code>
                        <PRE>
if (cipher_char === from_char) {
    result = result + to_char;
    x++;
} else {
    result = result + clear_char;
}
                          </PRE>
                     </code>
                    <code>
                        <PRE>
if (x > 50) {
    /* do something */
} else if (x > 5) {
    /* do something */
} else {
    /* do something */
}
                          </PRE>
                     </code>
                </div>
            </div>
        </section>



        <div class="sectionButton" id="sectioin5" data-section="section5"> Type Conversion and Coercion </div>
        <section class="sectionContent sectionContentHide" id="section5">
            <div class="content">

                <div class="discription">
                    Type coercion is the automatic or implicit conversion of values from one data type to another (such
                    as strings to numbers). Type conversion is similar to type coercion because they both convert values
                    from one data type to another with one key difference — type coercion is implicit whereas type
                    conversion can be either implicit or explicit.
<PRE>
<code>
const value1 = '5';
const value2 = 9;
let sum = value1 + value2;
console.log(sum);
sum = Number(value1) + value2;
</code>   
<code>
let num1 = '9';
let num2 = 9;
console.log('num1+num2=', num1+num2);// num1+num2 = 99
</code>   
<code>
let num1 = '10';
let num2 = 9;
console.log('num1-num2=', num1-num2);// num1-num2 = 1
</code> 
<code>
let num1 = '10';
let num2 = 9;
console.log('num1*num2=', num1*num2);// num1*num2 = 90
</code>  
</PRE>

                </div>
            </div>
        </section>


        <div class="sectionButton" id="sectioin6" data-section="section6"> Truthy and Falsy Values </div>
        <section class="sectionContent sectionContentHide" id="section6">
            <div class="content">

                <div class="discription">
                    In JavaScript, a truthy value is a value that is considered true when encountered in a Boolean context. All values are truthy unless they are defined as falsy (i.e., except for <code class="inline">false, 0, -0, 0n, "", null, undefined, and NaN).</code>
JavaScript uses type coercion in Boolean contexts.
Examples of truthy values in JavaScript (which will be coerced to true in boolean contexts, and thus execute the if block):
<PRE>
<code>
if (true)
if ({})
if ([])
if (42)
if ("0")
if ("false")
if (new Date())
if (-42)
if (12n)
if (3.14)
if (-3.14)
if (Infinity)
if (-Infinity)
</code>   
</PRE>

                </div>
            </div>
        </section>



        <div class="sectionButton" id="sectioin7" data-section="section7">  Equality Operators: == vs. === </div>
        <section class="sectionContent sectionContentHide" id="section7">
            <div class="content">

                <div class="discription">
                    The strict equality <code class="inline">operator (===)</code> behaves identically to the abstract equality operator <code class="inline">operator (==)</code> except no type conversion is done, and the types must be the same to be considered equal.
                    The <code class="inline">==</code>  operator will compare for equality after doing any necessary type conversions. The <code class="inline">===</code>  operator will not do the conversion, so if two values are not the same type <code class="inline">===</code>  will simply return false. Both are equally quick.
                    JavaScript has two sets of equality operators: <code class="inline">===</code>  and <code class="inline">!==</code> , and their evil twins <code class="inline">==</code>  and <code class="inline">!=</code> , The good ones work the way you would expect. If the two operands are of the same type and have the same value, then <code class="inline">===</code>  produces true and <code class="inline">!==</code>  produces false. The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values. the rules by which they do that are complicated and unmemorable. These are some of the interesting cases:
<PRE>
<code>
    '' == '0'           // false
    0 == ''             // true
    0 == '0'            // true
    
    false == 'false'    // false
    false == '0'        // true
    
    false == undefined  // false
    false == null       // false
    null == undefined   // true
    
    ' \t\r\n ' == 0     // true
</code>   
<code>
    var a = [1,2,3];
    var b = [1,2,3];
    
    var c = { x: 1, y: 2 };
    var d = { x: 1, y: 2 };
    
    var e = "text";
    var f = "te" + "xt";
    
    a == b            // false
    a === b           // false
    
    c == d            // false
    c === d           // false
    
    e == f            // true
    e === f           // true
</code>   
<code>
    "abc" == new String("abc")    // true
    "abc" === new String("abc")   // false
</code> 
</PRE>

                </div>
            </div>
        </section>



        <div class="sectionButton" id="sectioin8" data-section="section8">  Operator precedence </div>
        <section class="sectionContent sectionContentHide" id="section8">
            <div class="content">

                <div class="discription">
                    The precedence of operators determines the order they are applied when evaluating an expression. You can override operator precedence by using parentheses.
                    The following table describes the precedence of operators, from highest to lowest.
<PRE>
<code>
    member	. []
    call / create instance	() new
    negation/increment	! ~ - + ++ -- typeof void delete
    multiply/divide	* / %
    addition/subtraction	+ -
    bitwise shift	<< >> >>>
    relational	< <= > >= in instanceof
    equality	== != === !==
    bitwise-and	&
    bitwise-xor	^
    bitwise-or	|
    logical-and	&&
    logical-or	||
    conditional	?:
    assignment	= += -= *= /= %= <<= >>= >>>= &= ^= |= &&= ||= ??=
    comma	,
</code> 
</PRE>

                </div>
            </div>
        </section>


        <div class="sectionButton" id="sectioin9" data-section="section9"> The switch Statement </div>
        <section class="sectionContent sectionContentHide" id="section9">
            <div class="content">

                <div class="discription">
                    The <code class="inline">switch</code>  statement evaluates an expression, matching the expression's value to a <code class="inline">case</code>  clause, and executes statements associated with that <code class="inline">case</code> , as well as statements in cases that follow the matching case.
<PRE>
<code>
    const expr = 'Papayas';
    switch (expr) {
      case 'Oranges':
        console.log('Oranges are $0.59 a pound.');
        break;
      case 'Mangoes':
      case 'Papayas':
        console.log('Mangoes and papayas are $2.79 a pound.');
        // expected output: "Mangoes and papayas are $2.79 a pound."
        break;
      default:
        console.log(`Sorry, we are out of ${expr}.`);
    }
</code> 
<code>
    const expr = 'Papayas';
    switch (expr) {
      case 'Oranges':
        console.log('Oranges are $0.59 a pound.');
        break;
      case 'Mangoes':
      case 'Papayas':
        console.log('Mangoes and papayas are $2.79 a pound.');
        // expected output: "Mangoes and papayas are $2.79 a pound."
        break;
      default:
        console.log(`Sorry, we are out of ${expr}.`);
    }
</code>
</PRE>

                </div>
            </div>
        </section>


        <div class="sectionButton" id="sectioin10" data-section="section10"> Conditional (ternary) operator </div>
        <section class="sectionContent sectionContentHide" id="section10">
            <div class="content">

                <div class="discription">

                    The conditional (ternary) operator is the only JavaScript operator that takes three operands: a condition followed by a question mark <code class="inline">(?)</code> , then an expression to execute if the condition is truthy followed by a colon <code class="inline">(:)</code>, and finally the expression to execute if the condition is falsy. This operator is frequently used as a shortcut for the <code class="inline">if</code> statement.


<PRE>
<code>
    function getFee(isMember) {
        return (isMember ? '$2.00' : '$10.00');
      }
      
      console.log(getFee(true));
      // expected output: "$2.00"
      
      console.log(getFee(false));
      // expected output: "$10.00"
      
      console.log(getFee(null));
      // expected output: "$10.00"
</code> 
<code>
    function example(…) {
        return condition1 ? value1
             : condition2 ? value2
             : condition3 ? value3
             : value4;
    }
    
    // Equivalent to:
    
    function example(…) {
        if (condition1) { return value1; }
        else if (condition2) { return value2; }
        else if (condition3) { return value3; }
        else { return value4; }
    }
</code>
</PRE>

                </div>
            </div>
        </section>

        <div class="sectionButton" id="sectioin11" data-section="section11"> Activating Strict Mode </div>
        <section class="sectionContent sectionContentHide" id="section11">
            <div class="content">

                <div class="discription">

                    JavaScript's strict mode, introduced in ECMAScript 5, is a way to opt in to a restricted variant of JavaScript, thereby implicitly opting-out of "sloppy mode". Strict mode isn't just a subset: it intentionally has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.
<br>
<br>
Strict mode makes several changes to normal JavaScript semantics:
<ol>
    <li>Eliminates some JavaScript silent errors by changing them to throw errors.</li>
    <li>Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode.</li>
    <li>Prohibits some syntax likely to be defined in future versions of ECMAScript.</li>
</ol>

<br>
<h3>Invoking strict mode</h3><br>
To invoke strict mode for an entire script, put the exact statement "use strict"; (or 'use strict';) before any other statements.

<PRE>
<code>
// Whole-script strict mode syntax
'use strict';
var v = "Hi! I'm a strict mode script!";
</code> 
<code>
function strict() {
    // Function-level strict mode syntax
    'use strict';
    function nested() { return 'And so am I!'; }
    return "Hi!  I'm a strict mode function!  " + nested();
}
function notStrict() { return "I'm not strict."; }    
</code>
<code>
function strict() {
    // because this is a module, I'm strict by default
}
export default strict;    
</code>
<code>
'use strict';

// Assignment to a non-writable global
var undefined = 5; // throws a TypeError
var Infinity = 5; // throws a TypeError

// Assignment to a non-writable property
var obj1 = {};
Object.defineProperty(obj1, 'x', { value: 42, writable: false });
obj1.x = 9; // throws a TypeError

// Assignment to a getter-only property
var obj2 = { get x() { return 17; } };
obj2.x = 5; // throws a TypeError

// Assignment to a new property on a non-extensible object
var fixed = {};
Object.preventExtensions(fixed);
fixed.newProp = 'ohai'; // throws a TypeError    
</code>
<code>
'use strict';
var sum = 015 + // !!! syntax error
            197 +
            142;

var sumWithOctal = 0o10 + 8;
console.log(sumWithOctal); // 16    
</code>
<code>
(function() {
    'use strict';

    false.true = '';         // TypeError
    (14).sailing = 'home';   // TypeError
    'with'.you = 'far away'; // TypeError

})();    
</code>
</PRE>

                </div>
            </div>
        </section>




        <div class="sectionButton" id="sectioin12" data-section="section12"> Functions </div>
        <section class="sectionContent sectionContentHide" id="section12">
            <div class="content">

                <div class="discription">

                    Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

<br>
<h3>Defining functions</h3><br>
<h3>Function declarations</h3>
A function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:
<ol>
    <li>The name of the function.</li>
    <li>A list of parameters to the function, enclosed in parentheses and separated by commas.</li>
    <li>The JavaScript statements that define the function, enclosed in curly brackets, {...}.</li>
</ol>
<PRE>
<code>
function square(number) {
    return number * number;
}
</code> 
<code>
function strict() {
    // Function-level strict mode syntax
    'use strict';
    function nested() { return 'And so am I!'; }
    return "Hi!  I'm a strict mode function!  " + nested();
}
function notStrict() { return "I'm not strict."; }    
</code>
<code>
function myFunc(theObject) {
    theObject.make = 'Toyota';
}

var mycar = {make: 'Honda', model: 'Accord', year: 1998};
var x, y;

x = mycar.make; // x gets the value "Honda"

myFunc(mycar);
y = mycar.make; // y gets the value "Toyota"
                // (the make property was changed by the function)  
</code>
</PRE>

                </div>
            </div>
        </section>



        <div class="sectionButton" id="sectioin13" data-section="section13"> Function Declarations vs. Expressions </div>
        <section class="sectionContent sectionContentHide" id="section13">
            <div class="content">

                <div class="discription">
                    Function expressions
                    While the function declaration above is syntactically a statement, functions can also be created by a function expression.

                    Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:
<PRE>
<code>
const square = function(number) { return number * number }
var x = square(4) // x gets the value 16
    
</code> 
However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:
<code>
const factorial = function fac(n) { return n < 2 ? 1 : n * fac(n - 1) }
console.log(factorial(3))
</code>
Function expressions are convenient when passing a function as an argument to another function. The following example shows a map function that should receive a function as first argument and an array as second argument. 
<code>
function map(f, a) {
    let result = []; // Create a new Array
    let i; // Declare variable
    for (i = 0; i != a.length; i++)
        result[i] = f(a[i]);
    return result;
}
const f = function(x) {
    return x * x * x;
}
let numbers = [0, 1, 2, 5, 10];
let cube = map(f,numbers);
console.log(cube);
</code>
</PRE>

<h3>Calling functions</h3>
Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.<br>
Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:
<PRE>
<code>
square(5);
</code>
The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25.<BR>
Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code), as in this example:
<code>
console.log(square(5));
/* ... */
function square(n) { return n * n }    
</code>
The scope of a function is the function in which it is declared (or the entire program, if it is declared at the top level). <br>
Note: This works only when defining the function using the above syntax (i.e. <code class='inline'>function funcName(){}</code>). The code below will not work.<br>
This means that function hoisting only works with function declarations—not with function expressions.<br>
<error>
<PRE>
console.log(square)    // square is hoisted with an initial value undefined. 
console.log(square(5)) // Uncaught TypeError: square is not a function 
const square = function(n) { 
    return n * n; 
}     
</PRE>
</error>


</PRE>


                </div>
            </div>
        </section>

        


        <div class="sectionButton" id="sectioin14" data-section="section14"> Arrow Functions</div>
        <section class="sectionContent sectionContentHide" id="section14">
            <div class="content">

                <div class="discription">
                    Arrow functions – also called “fat arrow” functions, from CoffeeScript (a transcompiled language) — are a more concise syntax for writing function expressions. They utilize a new token, <code class="inline">=></code>, that looks like a fat arrow. Arrow functions are anonymous and change the way <code class="inline">this</code> binds in functions.
                    <br>
                    Arrow functions make our code more concise, and simplify function scoping and the this keyword. They are one-line mini functions which work much like Lambdas in other languages like C# or Python. By using arrow functions, we avoid having to type the function keyword, return keyword (it’s implicit in arrow functions), and curly brackets.
                    <h3>Using Arrow Functions</h3><br>
                    Basic Syntax with Multiple Parameters (from MDN)
                    <PRE>
<code>
// (param1, param2, paramN) => expression

// ES5
var multiplyES5 = function(x, y) {
    return x * y;
};
// ES6
const multiplyES6 = (x, y) => { return x * y };    
</code> 
The arrow function example above allows a developer to accomplish the same result with fewer lines of code and approximately half the typing.
Curly brackets aren’t required if only one expression is present. The preceding example could also be written as:
<code>
const multiplyES6 = (x, y) => x * y;
</code>
<h3>Basic Syntax with One Parameter</h3><br>
Parentheses are optional when only one parameter is present
<code>
//ES5
var phraseSplitterEs5 = function phraseSplitter(phrase) {
    return phrase.split(' ');
};

//ES6
const phraseSplitterEs6 = phrase => phrase.split(" ");

console.log(phraseSplitterEs6("ES6 Awesomeness"));  // ["ES6", "Awesomeness"]
</code>
</PRE>

<h3>No Parameters</h3><br>
Parentheses are required when no parameters are present.
<PRE>
<code>
//ES5
var docLogEs5 = function docLog() {
    console.log(document);
};

//ES6
var docLogEs6 = () => { console.log(document); };
docLogEs6();
</code>
</PRE>


                </div>
            </div>
        </section>


        <div class="sectionButton" id="sectioin15" data-section="section15"> Arrays</div>
        <section class="sectionContent sectionContentHide" id="section15">
            <div class="content">

                <div class="discription">
                    Arrays are list-like objects whose prototype has methods to perform traversal and mutation operations. Neither the length of a JavaScript array nor the types of its elements are fixed. Since an array's length can change at any time, and data can be stored at non-contiguous locations in the array, JavaScript arrays are not guaranteed to be dense; this depends on how the programmer chooses to use them. In general, these are convenient characteristics; but if these features are not desirable for your particular use, you might consider using typed arrays.<br>
                    Arrays cannot use strings as element indexes (as in an associative array) but must use integers. Setting or accessing via non-integers using bracket notation (or dot notation) will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.
                    <PRE>
<code>
let fruits = ['Apple', 'Banana']
console.log(fruits.length)
// 2
</code> 
<code>
let first = fruits[0]
// Apple

let last = fruits[fruits.length - 1]
// Banana
</code>
<code>
fruits.forEach(function(item, index, array) {
    console.log(item, index)
})
// Apple 0
// Banana 1
</code>
</PRE>
<PRE>
<code>
let newLength = fruits.push('Orange')
// ["Apple", "Banana", "Orange"]
let last = fruits.pop() // remove Orange (from the end)
// ["Apple", "Banana"]
let first = fruits.shift() // remove Apple from the front
// ["Banana"]
let newLength = fruits.unshift('Strawberry') // add to the front
// ["Strawberry", "Banana"]

fruits.push('Mango')
// ["Strawberry", "Banana", "Mango"]

let pos = fruits.indexOf('Banana')
// 1


let removedItem = fruits.splice(pos, 1) // this is how to remove an item

// ["Strawberry", "Mango"]




let vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot']
console.log(vegetables)
// ["Cabbage", "Turnip", "Radish", "Carrot"]

let pos = 1
let n = 2

let removedItems = vegetables.splice(pos, n)
// this is how to remove items, n defines the number of items to be removed,
// starting at the index position specified by pos and progressing toward the end of array.

console.log(vegetables)
// ["Cabbage", "Carrot"] (the original array is changed)

console.log(removedItems)
// ["Turnip", "Radish"]


let shallowCopy = fruits.slice() // this is how to make a copy
// ["Strawberry", "Mango"]



let arr = ['this is the first element', 'this is the second element', 'this is the last element']
console.log(arr[0])              // logs 'this is the first element'
console.log(arr[1])              // logs 'this is the second element'
console.log(arr[arr.length - 1]) // logs 'this is the last element'



const array1 = [1, 2, 3];

console.log(array1.includes(2));
// expected output: true

const pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));
// expected output: true

console.log(pets.includes('at'));
// expected output: false
</code>
</PRE>


                </div>
            </div>
        </section>

 
        <div class="sectionButton" id="sectioin16" data-section="section16"> Objects</div>
        <section class="sectionContent sectionContentHide" id="section16">
            <div class="content">

                <div class="discription">
                    JavaScript is designed on a simple object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method. In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, functions, and methods, and how to create your own objects.                    <br>
                    Like all JavaScript variables, both the object name (which could be a normal variable) and property name are case sensitive. You can define a property by assigning it a value. For example, let's create an object named myCar and give it properties named make, model, and year as follows:
<PRE>
<code>
var myCar = new Object();
myCar.make = 'Ford';
myCar.model = 'Mustang';
myCar.year = 1969;
</code> 
</PRE>

The above example could also be written using an object initializer, which is a comma-delimited list of zero or more pairs of property names and associated values of an object, enclosed in curly braces <code class="inline">({})</code>:
<PRE>
<code>
var myCar = {
    make: 'Ford',
    model: 'Mustang',
    year: 1969
};
</code>
</PRE>

Unassigned properties of an object are <code class="inline">undefined</code> (and not <code class="inline">null</code> ).
<PRE>
<code>
myCar.color; // undefined
</code>
</PRE>
Properties of JavaScript objects can also be accessed or set using a bracket notation (for more details see property accessors). Objects are sometimes called associative arrays, since each property is associated with a string value that can be used to access it. So, for example, you could access the properties of the myCar object as follows:
<PRE>
<code>
myCar['make'] = 'Ford';
myCar['model'] = 'Mustang';
myCar['year'] = 1969;  
</code>
</PRE>
An object property name can be any valid JavaScript string, or anything that can be converted to a string, including the empty string. However, any property name that is not a valid JavaScript identifier (for example, a property name that has a space or a hyphen, or that starts with a number) can only be accessed using the square bracket notation. This notation is also very useful when property names are to be dynamically determined (when the property name is not determined until runtime). Examples are as follows:
<PRE>
<code>
// four variables are created and assigned in a single go,
// separated by commas
var myObj = new Object(),
    str = 'myString',
    rand = Math.random(),
    obj = new Object();

myObj.type              = 'Dot syntax';
myObj['date created']   = 'String with space';
myObj[str]              = 'String value';
myObj[rand]             = 'Random Number';
myObj[obj]              = 'Object';
myObj['']               = 'Even an empty string';

console.log(myObj);
</code>
</PRE>


                </div>
            </div>
        </section>





         
        <div class="sectionButton" id="sectioin17" data-section="section17"> Loops and iteration
        </div>
        <section class="sectionContent sectionContentHide" id="section17">
            <div class="content">

                <div class="discription">
                    Loops offer a quick and easy way to do something repeatedly. This chapter of the JavaScript Guide introduces the different iteration statements available to JavaScript. <br>
You can think of a loop as a computerized version of the game where you tell someone to take X steps in one direction, then Y steps in another. For example, the idea "Go five steps to the east" could be expressed this way as a loop:
<PRE>
<code>
for (let step = 0; step < 5; step++) {
    // Runs 5 times, with values of step 0 through 4.
    console.log('Walking east one step');
}
</code> 
</PRE>
for statement
<PRE>
<code>
function howMany(selectObject) {
    let numberSelected = 0;
    for (let i = 0; i < selectObject.options.length; i++) {
        if (selectObject.options[i].selected) {
        numberSelected++;
        }
    }
    return numberSelected;
}
let btn = document.getElementById('btn');
btn.addEventListener('click', function() {
alert('Number of options selected: ' + howMany(document.selectForm.musicTypes));
});
</code>
</PRE>
do...while statement
<PRE>
<code>
let i = 0;
do {
    i += 1;
    console.log(i);
} while (i < 5);
</code>
</PRE>
while statement
<PRE>
<code>
let n = 0;
let x = 0;
while (n < 3) {
    n++;
    x += n;
}
</code>
<error>
// Infinite loops are bad!
while (true) {
    console.log('Hello, world!');
}
</error>
</PRE>
<h3>labeled statement</h3>
A label provides a statement with an identifier that lets you refer to it elsewhere in your program. For example, you can use a label to identify a loop, and then use the break or continue statements to indicate whether a program should interrupt the loop or continue its execution.
<PRE>
<code>
label :
    statement
</code>
</PRE>
The value of <code class="inline">label</code> may be any JavaScript identifier that is not a reserved word. The statement that you identify with a <code class="inline">label</code> may be any statement.
<PRE>
<code>
markLoop:
while (theMark === true) {
    doSomething();
}
</code>
</PRE>
<h3>for...in statement</h3>
The <code class="inline">for...in</code> statement iterates a specified variable over all the enumerable properties of an object. For each distinct property, JavaScript executes the specified statements. A <code class="inline">for...in </code>  statement looks as follows:
<PRE>
<code>
for (variable in object)
    statement
//
function dump_props(obj, obj_name) {
    let result = '';
    for (let i in obj) {
        result += obj_name + '.' + i + ' = ' + obj[i] + '<br>';
    }
    result += '<hr>';
    return result;
    }
</code>
</PRE>
<h3>for...of statement</h3>
The <code class="inline">for...of</code> statement creates a loop Iterating over iterable objects (including Array, Map, Set, arguments object and so on), invoking a custom iteration hook with statements to be executed for the value of each distinct property.
The following example shows the difference between a <code class="inline">for...of</code> loop and a <code class="inline">for...in </code> loop. While <code class="inline">for...in</code> iterates over property names, <code class="inline">for...of</code> iterates over property values:
<PRE>
<code>
const arr = [3, 5, 7];
arr.foo = 'hello';

for (let i in arr) {
    console.log(i); // logs "0", "1", "2", "foo"
}

for (let i of arr) {
    console.log(i); // logs 3, 5, 7
}
</code>
</PRE>

                </div>
            </div>
        </section>

    </div>
    <script src="out/js/main.js"></script>
</body>

</html>